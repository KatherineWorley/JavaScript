<!DOCTYPE html>
<html>
<head>
	<title>Some more Arrays.</title>
</head>
<body>
<script type="text/javascript">

// MAP
// It takes one parameter: a function that is called on every element of the array. And it returns a new array.


	
const numbers = [1,2,3,4,5,6,7,8,9,10];

const numbersPlusOne = numbers.map(n => n + 1);
console.log(numbersPlusOne);

const numbersPlusForty = numbers.map(n => n + 1);
console.log(numbersPlusForty);

const numbersPlusTwo = numbers.map(n => n + 2);
console.log(numbersPlusTwo);

const numbersPlusThree = numbers.map(n => n + 3);
console.log(numbersPlusThree);

const numbersTimesFour = numbers.map(n => n * 4);
console.log(numbersTimesFour);

const numbersDividedByTwo = numbers.map(n => n % 2);
console.log(numbersDividedByTwo);

const numbersDividedByThree = numbers.map(n => n % 10);
console.log(numbersDividedByThree);

const numbersTimesTwo = numbers.map(n => n * 2);
console.log(numbersTimesTwo);

const numbersMinusTwo = numbers.map(n => n - 2);
console.log(numbersMinusTwo);

const numbersMinusTen = numbers.map(n => n - 10);
console.log(numbersMinusTen);

const numbersPlusThirtyFive = numbers.map(n => n + 35);
console.log(numbersPlusThirtyFive);

const numbersMinusFive = numbers.map(n => n- 5);
console.log(numbersMinusFive);

const numbersPlusOneHundred = numbers.map(n => n + 100);
console.log(numbersPlusOneHundred);

const numbersMinusTwenty = numbers.map(n => n - 20);
console.log(numbersMinusTwenty);

const numbersPlusFive = numbers.map(n => n +5);
console.log(numbersPlusFive);

const numbersPlusThirty = numbers.map(n => n + 30);
console.log(numbersPlusThirty);

const numbersPlusFour = numbers.map(n => n + 4);
console.log(numbersPlusFour);

const numbersPlusFiftyFive = numbers.map(n => n + 55);
console.log(numbersPlusFiftyFive);

const numbersTimesOne = numbers.map(n => n * 1);
console.log(numbersTimesOne);

const numbersPlusEight = numbers.map(n => n + 8);
console.log(numbersPlusEight);

const numbersMinusThree = numbers.map(n => n - 3);
console.log(numbersMinusThree);

const numbersTimesEight = numbers.map(n => n * 8);
console.log(numbersTimesEight);

const numbersPlusTwenty = numbers.map(n => n + 20);
console.log(numbersPlusTwenty);

const numbersTimesForty = numbers.map (n => n * 40);
console.log(numbersTimesForty);

const numbersDividedByFive = numbers.map(n => n % 5);
console.log(numbersDividedByFive);

const numbersDividedByTen = numbers.map(n => n % 10);
console.log(numbersDividedByTen);

const numbersDividedByZero = numbers.map(n => n % 0);
console.log(numbersDividedByZero);

const numbersDividedByOne = numbers.map(n => n % 1);
console.log(numbersDividedByOne);

const numbersMinusEight = numbers.map(n => n - 8);
console.log(numbersMinusEight);

const numbersPLusEight = numbers.map(n => n + 8);
console.log(numbersPLusEight);

const numbersPlusNine = numbers.map(n => n + 9);
console.log(numbersPlusNine);

const numbersDividedByEight = numbers.map(n => n % 8);
console.log(numbersDividedByEight);

const numbersPlusOneHundredFive = numbers.map(n => n + 105);
console.log(numbersPlusOneHundredFive);

// MAP
// Also create a new array that keeps only one particular property of an object:

const allActivities = [
{ title: 'My Activity',
coordinates: [50.123, 3.291]},
{ title: 'Another Activity', coordinates: [1.238, 4.292]},
];
const allCoordinates = allActivities.map(activity => activity.coordinates);
console.log(allCoordinates);

// FILTER
// Takes a function as its only parameter that is called on every element of the array. This function needs to return a boolean: true if you want to keep the element in the array false if you don’t want to keep it. Then you’ll have a shiny new array with the elements you wanted to keep.

const oddNumbers = numbers.filter(n => n % 2 !== 0);
console.log(oddNumbers); // [1, 3, 5]

const oddNumbersTwo = numbers.filter(n => n % 2 !== 0);
console.log(oddNumbersTwo);

const oddNumbersFive = numbers.filter(n => n % 5 !== 0);
console.log(oddNumbersFive);

const oddNumbersThree = numbers.filter(n => n % 3 !== 0);
console.log(oddNumbersThree);

const oddNumbersFour = numbers.filter(n => n % 4 !==0);
console.log(oddNumbersFour);

const evenNumbers = numbers.filter(n => n % 2 ===0);
console.log(evenNumbers);

const evenNumbersPlusTwo = numbers.filter(n => n % 2 ===0);
console.log(evenNumbersPlusTwo);

const evenNumbersMinusOne = numbers.filter(n => n - 1);
console.log(evenNumbersMinusOne);

const participantsOne = [
	{ id: 'a3f47', username: 'john'},
	{ id: 'fek28', username: 'mary'},
	{ id: 'nej44', username: 'sam'},
];

function removeParticipant(participantsOne, id) {
	return participantsOne.filter(participant => participant.id !== id)
};

console.log(removeParticipant(participantsOne, 'a3f47'));


const sports = ['football', 'archery', 'judo'];
const hasFootball = sports.includes('football');
console.log(hasFootball);

// REDUCE - reduce is about taking an array of values and combine them into one value. It takes two parameters, a callback function which is our reducer and an optional initial value (which is the first item of the array by default). The reducer itself takes four parameters:

// The accumulator: it accumulates the returned values in your reducer.
// The current value of the array
// The current index
// The array reduce was called upon
// Most of the time, you’ll just use the first two parameters: the accumulator and the current value.


const total = numbers.reduce((total, n) => total + n)
console.log(total) 

// Spread operator (ES2015)



const numbersCopy = [...numbers]
console.log(numbersCopy) // [1, 2, 3]

const otherNumbers = [4, 5, 6]
const numbersConcatenated = [...numbers, ...otherNumbers]
console.log(numbersConcatenated) // [1, 2, 3, 4, 5, 6]


const arr = ['foo', 42, { name: 'Thomas' }]
let copy = [...arr]

copy[0] = 'bar'

console.log(arr) // No mutations: ["foo", 42, { name: "Thomas" }]
console.log(copy) // ["bar", 42, { name: "Thomas" }]

copy[2].name = 'Hello'

console.log(arr) // /!\ MUTATION ["foo", 42, { name: "Hello" }]
console.log(copy) // ["bar", 42, { name: "Hello" }]

// includes (ES2015)

const sportsTwo = ['football', 'archery', 'judo']
const hasFootballTwo = sportsTwo.includes('football')
console.log(hasFootballTwo) // true

// ForEach takes a function as a parameter that takes itself three parameters: the current value, the index and the array.


numbers.forEach(console.log)

// indexOf
// It is used to return the first index at which a given element can be found in the array. indexOf was also widely used to check whether an element is in an array or not. To be honest, I don’t use it that much as of today.
const sportsThree = ['football', 'archery', 'judo']

const judoIndex = sportsThree.indexOf('judo')
console.log(judoIndex) // 2

// find
// The find method is quite similar to the filter method. You have to provide it a function that test each array’s element. However, find stops testing elements as soons as it finds one that passes the test. Not filter. filter will iterate over the whole array no matter what.

const usersTwo = [
  { id: 'af35', name: 'john' },
  { id: '6gbe', name: 'mary' },
  { id: '932j', name: 'gary' },
]

const user = usersTwo.find(user => user.id === '6gbe')
console.log(user) // { id: '6gbe', name: 'mary' }

// findIndex
// It’s exactly the same as the find method except that it returns the index of the first element found instead of the element directly.

const usersThree = [
  { id: 'af35', name: 'john' },
  { id: '6gbe', name: 'mary' },
  { id: '932j', name: 'gary' },
]

const userThree = usersThree.findIndex(user => userThree.id === '6gbe')
console.log(userThree) // 1

// slice
// Whenever you need to take a portion of an array or copy an array, you can use slice. But be careful, just like the spread operator, slice returns a shallow copy of that portion!


const copyTwo = numbers.slice()

// some - If you want to test that at least one element of an array passes a test, well you can use some. Just like map, filter or find, some takes a callback function as its only parameter. It returns true if at least one element pass the test, false otherwise. You can use some when you are dealing with permissions for example:

const usersW = [
  {
    id: 'fe34',
    permissions: ['read', 'write'],
  },
  {
    id: 'a198',
    permissions: [],
  },
  {
    id: '18aa',
    permissions: ['delete', 'read', 'write'],
  },
]

const hasDeletePermission = usersW.some(user =>
  user.permissions.includes('delete')
)
console.log(hasDeletePermission) // true

// every
// Similar to some except that every tests if all elements pass the condition (instead of at least one).

const usersId = [
  {
    id: 'fe34',
    permissions: ['read', 'write'],
  },
  {
    id: 'a198',
    permissions: [],
  },
  {
    id: '18aa',
    permissions: ['delete', 'read', 'write'],
  },
]

const hasAllReadPermission = usersId.every(user =>
  user.permissions.includes('read')
)
console.log(hasAllReadPermission) // false

// flat (ES2019)
// These are the brand new methods that are coming in the JavaScript world. Basically, flat creates a new array by concatenating all sub-array elements into it. It accepts one parameter, a number, which represents how deep you want to flatten your array:

const numbersDeep = [1, 2, [3, 4, [5, [6, 7]], [[[[8]]]]]]

const numbersflattenOnce = numbersDeep.flat()
console.log(numbersflattenOnce) // [1, 2, 3, 4, Array[2], Array[1]]

const numbersflattenTwice = numbersDeep.flat(2)
console.log(numbersflattenTwice) // [1, 2, 3, 4, 5, Array[2], Array[1]]

const numbersFlattenInfinity = numbersDeep.flat(Infinity)
console.log(numbersFlattenInfinity) // [1, 2, 3, 4, 5, 6, 7, 8]

// flatMap (ES2019)
// Can you guess what this method does? I bet you can just with the name.

// First it runs a mapping function on each element. Then it flattens the array once. Easy peasy!

const sentences = [
  'This is a sentence',
  'This is another sentence',
  "I can't find any original phrases",
]

const allWords = sentences.flatMap(sentence => sentence.split(' '))
console.log(allWords) // ["This", "is", "a", "sentence", "This", "is", "another", "sentence", "I", "can't", "find", "any", "original", "phrases"]

// join
// If you need to create a string based on the array’s elements, you’re looking for join. It allows to create a new string by concatenating all the array’s elements, separated by a provided separator.

// For example, you can display at a glance all the participants of an activity using join:


const participants = ['john', 'mary', 'gary']
const participantsFormatted = participants.join(', ')
console.log(participantsFormatted) // john, mary, gary


// from
// This is a static method that creates a new Array from an array-like or iterable object like a string for example. It can be useful when you’re working with the dom.

const nodes = document.querySelectorAll('.todo-item') // this is an instance of NodeList
const todoItems = Array.from(nodes) // now, you can use map, filter, etc. as you're workin with an array!

// Then you can have fun with these nodes and for example registering an event listener on each one of them with forEach:

todoItems.forEach(item => {
  item.addEventListener('click', function() {
    alert(`You clicked on ${item.innerHTML}`)
  })
})

// isArray
// While we’re at it, let’s talk about another static method of Array which is isArray. Without surprises, it tells you if the passed value is an array or not.

// Based on the previous example, this is what we get:

const nodesThree = document.querySelectorAll('.todo-item')
console.log(Array.isArray(nodesThree)) // false
const todoItems = Array.from(nodesThree)
console.log(Array.isArray(todoItems)) // true

const arr = [1, 2, 3, 4, 5]
const copy = [...arr] // or arr.slice()

// sort
// Yes, sort modifies the original array. In fact, it sorts the elements of an array in place. The default sorting method transforms all the elements into strings and sort them alphabetically:

const names = ['john', 'mary', 'gary', 'anna']
names.sort()
console.log(names) // ['anna', 'gary', 'john', 'mary']

const numbersBig = [23, 12, 17, 187, 3, 90]
numbers.sort()
console.log(numbersBig) // [12, 17, 187, 23, 3, 90] 

// Then, how to sort the array? Well, sort accepts one function, a comparison function. This function accepts two parameters: the first element (let’s call it a) and the second element for comparison (b). The comparison between these two elements need to return a number:

// If it’s negative, a is sorted before b
// If it’s positive, b is sorted before a
// No changes if it’s 0.
// Then you can sort numbers that way:


const numbers = [23, 12, 17, 187, 3, 90]
numbers.sort((a, b) => a - b)
console.log(numbers) // [3, 12, 17, 23, 90, 187]

const posts = [
  {
    title: 'Create a Discord bot under 15 minutes',
    date: new Date(2018, 11, 26),
  },
  { title: 'How to get better at writing CSS', date: new Date(2018, 12, 17) },
  { title: 'JavaScript arrays', date: new Date() },
]
posts.sort((a, b) => a.date - b.date) // Substracting two dates returns the difference in millisecond between them
console.log(posts)

// fill modifies or fills all the elements of an array from a start index to an end index with a static value. A great use of fill is to fill a new array with static values.

// Normally I would have called a function that generates ids and random names but let's not bother with that here.
function fakeUser() {
  return {
    id: 'fe38',
    name: 'thomas',
  }
}

const posts = Array(3).fill(fakeUser())
console.log(posts) // [{ id: "fe38", name: "thomas" }, { id: "fe38", name: "thomas" }, { id: "fe38", name: "thomas" }]

// I think the method’s name is pretty clear here. However, keep in mind that just like sort does, reverse reverses the array in place!

const numbers = [1, 2, 3, 4, 5]

numbers.reverse()
console.log(numbers) // [5, 4, 3, 2, 1]


// pop
// That one removes the last element from an array and returns it.

const messages = ['Hello', 'Hey', 'How are you?', "I'm fine"]
const lastMessage = messages.pop()
console.log(messages) // ['Hello', 'Hey', 'How are you?']
console.log(lastMessage) // I'm fine

// push
// This is a widely used method when working with arrays. In fact push allows you to add one or more elements to an array. It is also usually used to build a new array based on an old one.

const todoItems = [1, 2, 3, 4, 5]

const itemsIncremented = []
for (let i = 0; i < items.length; i++) {
  itemsIncremented.push(items[i] + 1)
}

console.log(itemsIncremented) // [2, 3, 4, 5, 6]

const todos = ['Write an article', 'Proofreading']
todos.push('Publish the article')
console.log(todos) // ['Write an article', 'Proofreading', 'Publish the article']


</script>

</body>
</html>